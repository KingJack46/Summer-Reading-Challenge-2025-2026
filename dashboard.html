<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Library Reading Challenge</title>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 20px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 0;
      border-bottom: 1px solid #ccc;
    }

    .profile {
      position: relative;
      width: 40px;
      height: 40px;
      background-color: #007bff;
      color: white;
      font-weight: bold;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      cursor: pointer;
    }

    .dropdown {
      display: none;
      position: absolute;
      top: 50px;
      right: 0;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      overflow: hidden;
      z-index: 10;
    }

    .dropdown button {
      width: 100%;
      padding: 10px;
      border: none;
      background: none;
      cursor: pointer;
      text-align: left;
    }

    .dropdown button:hover {
      background-color: #f0f0f0;
    }

    .section {
      margin: 20px 0;
      background: #fff;
      border-radius: 6px;
      padding: 20px;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
    }

    /* Leaderboard */
    .leaderboard-bar {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
    }

    .leaderboard-profile {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #007bff;
      color: #fff;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 10px;
    }

    .leaderboard-label {
      font-weight: 600;
      margin-left: 10px;
    }

    /* Progress Bar */
    .progress-container {
      position: relative;
      height: 30px;
      background-color: #e0e0e0;
      border-radius: 15px;
      overflow: visible;
      margin-top: 15px;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #007bff, #00bfff);
      width: 0%;
      transition: width 0.5s ease;
      border-radius: 15px 0 0 15px;
    }

    .milestone {
      position: absolute;
      top: -8px;
      width: 2px;
      height: 46px;
      background: #555;
      z-index: 2;
    }

    .milestone-label {
      position: absolute;
      bottom: 100%;
      margin-bottom: 8px;
      font-size: clamp(9px, 1.2vw, 11px);
      transform: translateX(-50%);
      color: #333;
      font-weight: 500;
      white-space: nowrap;
      z-index: 3;
    }

    .progress-text {
      margin-top: 10px;
      font-weight: bold;
    }

    /* Inputs + Buttons */
    input, button {
      margin-right: 10px;
    }

    button {
      cursor: pointer;
    }

    .submit-minutes {
      background-color: #28a745;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
    }

    .submit-minutes:hover {
      background-color: #218838;
    }
    #bingoBoard {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
  max-width: 90vw;       /* fills screen on mobile */
  width: 60%;            /* 60% on larger screens */
  margin: 0 auto;        /* center horizontally */
}

#bingoBoard div {
  padding-top: 100%;     /* makes square aspect ratio */
  position: relative;
  border: 2px solid #555;
  border-radius: 10px;
  background-color: #f0f0f0;
  text-align: center;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.3s, transform 0.2s;
}

#bingoBoard div.completed {
  background-color: #28a745;
  color: white;
}

#bingoBoard div span {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 5px;
}

  </style>
</head>
<body>
  <header>
    <h1>Library Reading Challenge</h1>
    <div id="profileIcon" class="profile">
      <span id="profileInitial">U</span>
      <div id="profileDropdown" class="dropdown">
        <button id="logoutBtn">Logout</button>
      </div>
    </div>
  </header>

  <main>
    <section id="welcomeSection" class="section">
      <h2 id="welcomeMessage">Welcome back!</h2>
    </section>

    <section id="leaderboardSection" class="section">
      <h3>Top 10 Leaderboard</h3>
      <div id="leaderboardContainer"></div>
    </section>

    <section id="communitySection" class="section">
      <h3>Community Progress</h3>
      <div id="communityProgressBar" class="progress-container">
        <div id="progressFill" class="progress-bar"></div>
      </div>
      <div id="progressText" class="progress-text"></div>
    </section>

    <section id="userMinutesSection" class="section">
      <h3>Your Logged Minutes</h3>
      <p id="userMinutes">0 minutes</p>
    </section>

    <section id="logMinutesSection" class="section">
      <h3>Log Reading Time</h3>
      <input id="bookTitleInput" type="text" placeholder="Book Title" />
      <input id="minutesInput" type="number" placeholder="Minutes" min="1" max="120" />
      <button id="logMinutesBtn" class="submit-minutes">Log Minutes</button>
      <p id="logMessage" style="color:red;"></p>

      <p id="stopwatchDisplay" style="font-weight:bold;">‚è± 00:00</p>
      <button id="stopwatchBtn" style="background:#007bff;color:white;border:none;padding:8px 12px;border-radius:4px;">
        Start Stopwatch
      </button>
    </section>

    <section id="bingoSection" class="section">
    <h3>Reading Bingo</h3>
    <p>Click a square when you complete a challenge to earn bonus minutes!</p>
    <div id="bingoBoard" style="display:grid; grid-template-columns:repeat(5, 1fr); gap:5px; max-width:500px;"></div>
</section>

  </main>

  <script>
    /* ========= CONFIG ========= */
    const SUPABASE_URL = 'https://hfugnpqguidgosxyuioj.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhmdWducHFndWlkZ29zeHl1aW9qIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI0NjE3ODAsImV4cCI6MjA3ODAzNzc4MH0.eawP-KaZTXOAE_OSYeJR6Ds_c6aKsqOsXo_EGifgtrU';
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const COMMUNITY_GOAL = 2_000_000;
    let currentUser = null;
    let stopwatchInterval = null;
    let startTime = null;

    /* ========= UTILS ========= */
    function formatTime(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    /* ========= SUPABASE HELPERS ========= */
    async function getUserData(username) {
      const { data, error } = await supabase.from('Userdetails').select('*').ilike('user_name', username).single();
      if (error) throw error;
      return data;
    }

    async function getUserLogs(username) {
      const { data, error } = await supabase.from('loghistory').select('minutes_logged').ilike('user_name', username);
      if (error) throw error;
      return data;
    }

    async function getAllUsers() {
      const { data, error } = await supabase.from('Userdetails').select('user_name, minutes_logged');
      if (error) throw error;
      return data;
    }

    async function getAllLogs() {
      const { data, error } = await supabase.from('loghistory').select('minutes_logged');
      if (error) throw error;
      return data;
    }

    async function logReadingMinutes(user, minutes, bookTitle) {
      const { error } = await supabase.from('loghistory').insert([{
        user_name: user.user_name,
        minutes_logged: minutes,
        book_title: bookTitle,
        time_logged: new Date().toISOString()
      }]);
      loadDashboard();
      if (error) throw error;
    }

    /* ========= RENDER FUNCTIONS ========= */
    function renderWelcome(user) {
      document.getElementById('profileInitial').textContent = user.user_name[0].toUpperCase();
      document.getElementById('welcomeMessage').textContent = `Welcome back, ${user.user_name}!`;
    }

    function renderUserMinutes(total) {
      document.getElementById('userMinutes').textContent = `${total.toLocaleString()} minutes`;
    }

    function renderLeaderboard(users) {
      const container = document.getElementById('leaderboardContainer');
      container.innerHTML = '';
      if (!users.length) return (container.textContent = 'No leaderboard data available.');

      users
        .sort((a, b) => b.minutes_logged - a.minutes_logged)
        .slice(0, 10)
        .forEach(user => {
          const bar = document.createElement('div');
          bar.classList.add('leaderboard-bar');
          bar.innerHTML = `
            <div class="leaderboard-profile">${user.user_name[0].toUpperCase()}</div>
            <div style="background:#007bff;width:${Math.min(user.minutes_logged / 10,300)}px;height:30px;border-radius:4px;"></div>
            <div class="leaderboard-label">${user.user_name}: ${user.minutes_logged} min</div>
          `;
          container.appendChild(bar);
        });
    }

    function renderProgressBar(total) {
      const fill = document.getElementById('progressFill');
      const text = document.getElementById('progressText');
      const container = document.getElementById('communityProgressBar');
      const percent = Math.min((total / COMMUNITY_GOAL) * 100, 100);
      fill.style.width = `${percent}%`;
      text.textContent = `Community has logged ${total.toLocaleString()} of ${COMMUNITY_GOAL.toLocaleString()} minutes (${percent.toFixed(2)}%)`;

      container.querySelectorAll('.milestone, .milestone-label').forEach(el => el.remove());
      const milestones = [10000, 50000, 100000];
      for (let i = 200000; i <= COMMUNITY_GOAL; i += 100000) milestones.push(i);

      milestones.forEach(ms => {
        const pos = (ms / COMMUNITY_GOAL) * container.offsetWidth;
        const line = document.createElement('div');
        line.className = 'milestone';
        line.style.left = `${pos}px`;

        const label = document.createElement('div');
        label.className = 'milestone-label';
        label.textContent = ms >= 1_000_000 ? (ms / 1_000_000).toFixed(1) + 'M' : (ms >= 1000 ? (ms / 1000) + 'k' : ms);
        label.style.left = `${pos}px`;

        container.append(line, label);
      });
    }

    /* ========= DASHBOARD LOADER ========= */
    async function loadDashboard() {
      const username = sessionStorage.getItem('username');
      if (!username) return (window.location.href = 'login.html');

      currentUser = await getUserData(username);
      renderWelcome(currentUser);

      const userLogs = await getUserLogs(username);
      const totalUserMinutes = userLogs.reduce((s, e) => s + e.minutes_logged, 0);
      renderUserMinutes(totalUserMinutes);

      await supabase.from('Userdetails').update({ minutes_logged: totalUserMinutes }).ilike('user_name', username);

      const allUsers = await getAllUsers();
      renderLeaderboard(allUsers);

      const allLogs = await getAllLogs();
      const totalCommunityMinutes = allLogs.reduce((s, e) => s + e.minutes_logged, 0);
      renderProgressBar(totalCommunityMinutes);
      await loadBingo();
    }

/* ========= BINGO LOGIC (FIXED) ========= */
const BINGO_SIZE = 5;
let bingoData = [];
let userBingoState = Array(BINGO_SIZE).fill(null).map(() => Array(BINGO_SIZE).fill(false));
let BINGO_WIN_BONUS = 20;

/* Load Bingo Challenges */
async function getBingoData() {
  const { data, error } = await supabase.from("bingochallenges").select("*");
  if (error) throw error;
  return data;
}

/* Load User Bingo State */
async function getUserBingoState(username) {
  const { data, error } = await supabase
    .from("user_bingo_state")
    .select("*")
    .ilike("user_name", username);

  if (error) throw error;

  const state = Array(BINGO_SIZE).fill(null).map(() => Array(BINGO_SIZE).fill(false));

  if (data) {
    data.forEach(row => {
      const r = Math.floor(row.bingo_index / BINGO_SIZE);
      const c = row.bingo_index % BINGO_SIZE;
      state[r][c] = row.completed;
    });
  }

  return state;
}

/* Render bingo board */
function renderBingoBoard(challenges) {
  const board = document.getElementById("bingoBoard");
  board.innerHTML = "";
  bingoData = challenges;

  challenges.forEach((item, index) => {
    const cell = document.createElement("div");
    const span = document.createElement("span");
    span.textContent = item.challenge;
    cell.appendChild(span);

    const row = Math.floor(index / BINGO_SIZE);
    const col = index % BINGO_SIZE;

    if (userBingoState[row][col]) cell.classList.add("completed");

    cell.addEventListener("click", () => handleBingoClick(index, cell));
    board.appendChild(cell);
  });
}

/* Utility: check ANY bingo on arbitrary board state */
function checkAnyBingo(state) {
  // rows
  for (let r = 0; r < BINGO_SIZE; r++) {
    if (state[r].every(v => v)) return true;
  }
  // columns
  for (let c = 0; c < BINGO_SIZE; c++) {
    if (state.every(row => row[c])) return true;
  }
  // diagonal TL ‚Üí BR
  if (state.every((row, i) => row[i])) return true;
  // diagonal TR ‚Üí BL
  if (state.every((row, i) => row[BINGO_SIZE - 1 - i])) return true;

  return false;
}

/* Handle Bingo Toggle (FIXED) */
async function handleBingoClick(index, cell) {
  const row = Math.floor(index / BINGO_SIZE);
  const col = index % BINGO_SIZE;
  const bonus = bingoData[index].bonus_minutes;
  const challengeName = bingoData[index].challenge;

  /* Deep clone previous state to compare before/after state */
  const prevState = JSON.parse(JSON.stringify(userBingoState));

  const wasCompleted = userBingoState[row][col];
  const newCompleted = !wasCompleted;

  /* Optimistic UI update */
  userBingoState[row][col] = newCompleted;
  cell.classList.toggle("completed", newCompleted);

  /* Compute bingo BEFORE and AFTER toggle (correct way!) */
  const hadBingoBefore = checkAnyBingo(prevState);
  const hasBingoAfter = checkAnyBingo(userBingoState);

  try {
    /* DB Sync: upsert row */
    const { data: existing } = await supabase
      .from("user_bingo_state")
      .select("*")
      .eq("user_name", currentUser.user_name)
      .eq("bingo_index", index)
      .limit(1);

    if (existing && existing.length > 0) {
      await supabase
        .from("user_bingo_state")
        .update({
          completed: newCompleted,
          completed_at: newCompleted ? new Date().toISOString() : null
        })
        .eq("user_name", currentUser.user_name)
        .eq("bingo_index", index);
    } else {
      await supabase.from("user_bingo_state").insert([
        {
          user_name: currentUser.user_name,
          bingo_index: index,
          completed: true,
          completed_at: new Date().toISOString()
        }
      ]);
    }

    /* Award or remove square bonus */
    await logReadingMinutes(
      currentUser,
      newCompleted ? bonus : -bonus,
      `${newCompleted ? "Bingo" : "Unmark Bingo"}: ${challengeName}`
    );

    /* Award bingo win */
    if (!hadBingoBefore && hasBingoAfter) {
      await logReadingMinutes(currentUser, BINGO_WIN_BONUS, "Bingo Board Win");
    }

    /* Remove bingo win */
    if (hadBingoBefore && !hasBingoAfter) {
      await logReadingMinutes(currentUser, -BINGO_WIN_BONUS, "Bingo Board Win Reverted");
    }

  } catch (err) {
    console.error(err);

    /* Rollback on error */
    userBingoState[row][col] = wasCompleted;
    cell.classList.toggle("completed", wasCompleted);

    /* Reload to guarantee correct state */
    await loadBingo();
  }
}

/* Load bingo (unchanged) */
async function loadBingo() {
  try {
    const data = await getBingoData();
    if (!data || data.length < 25) {
      console.warn("Not enough bingo challenges.");
      return;
    }

    BINGO_WIN_BONUS = data.find(d => d.type === "win_bonus")?.bonus_minutes || 20;

    userBingoState = await getUserBingoState(currentUser.user_name);
    renderBingoBoard(data.slice(0, 25));
  } catch (err) {
    console.error("Error loading bingo:", err.message);
  }
}


    function checkAnyBingo() {
  // check rows
  for (let r = 0; r < BINGO_SIZE; r++) {
    if (userBingoState[r].every(v => v)) return true;
  }
  // check columns
  for (let c = 0; c < BINGO_SIZE; c++) {
    if (userBingoState.every(row => row[c])) return true;
  }
  // check diagonals
  if (userBingoState.every((row, i) => row[i])) return true;
  if (userBingoState.every((row, i) => row[BINGO_SIZE - 1 - i])) return true;

  return false;
}

    /* ========= EVENT HANDLERS ========= */
    document.getElementById('profileIcon').addEventListener('click', e => {
      e.stopPropagation();
      const dropdown = document.getElementById('profileDropdown');
      dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
    });

    document.addEventListener('click', e => {
      if (!document.getElementById('profileIcon').contains(e.target))
        document.getElementById('profileDropdown').style.display = 'none';
    });

    document.getElementById('logoutBtn').addEventListener('click', () => {
      sessionStorage.removeItem('username');
      window.location.href = 'login.html';
    });

    document.getElementById('logMinutesBtn').addEventListener('click', async () => {
      const minutes = parseInt(document.getElementById('minutesInput').value);
      const title = document.getElementById('bookTitleInput').value.trim();
      const msg = document.getElementById('logMessage');
      msg.textContent = '';
      if (!title) return (msg.textContent = 'Please enter a book title.');
      if (isNaN(minutes) || minutes < 1 || minutes > 120)
        return (msg.textContent = 'Enter a valid number of minutes (1‚Äì120).');

      try {
        await logReadingMinutes(currentUser, minutes, title);
        document.getElementById('minutesInput').value = '';
        document.getElementById('bookTitleInput').value = '';
        await loadDashboard();
      } catch (err) {
        msg.textContent = 'Error logging minutes: ' + err.message;
      }
    });

    // üïí Stopwatch Feature
    document.getElementById('stopwatchBtn').addEventListener('click', async () => {
      const display = document.getElementById('stopwatchDisplay');
      const btn = document.getElementById('stopwatchBtn');
      const msg = document.getElementById('logMessage');
      msg.textContent = '';

      if (!stopwatchInterval) {
        startTime = Date.now();
        btn.textContent = 'Stop Stopwatch';
        stopwatchInterval = setInterval(() => {
          const elapsed = Date.now() - startTime;
          display.textContent = '‚è± ' + formatTime(elapsed);
        }, 1000);
        return;
      }

      const title = document.getElementById('bookTitleInput').value.trim();
      if (!title) return (msg.textContent = 'Please enter the book title before stopping the stopwatch.');

      clearInterval(stopwatchInterval);
      stopwatchInterval = null;
      btn.textContent = 'Start Stopwatch';

      const elapsedMinutes = Math.round((Date.now() - startTime) / 60000);
      if (elapsedMinutes < 1) return (msg.textContent = 'Session too short to log (<1 min).');

      if (confirm(`You read "${title}" for about ${elapsedMinutes} minute(s). Log this time?`)) {
        await logReadingMinutes(currentUser, elapsedMinutes, title);
        document.getElementById('bookTitleInput').value = '';
        await loadDashboard();
      }
    });

    window.addEventListener('resize', async () => {
      const allLogs = await getAllLogs();
      const total = allLogs.reduce((s, e) => s + e.minutes_logged, 0);
      renderProgressBar(total);
    });

    /* ========= INIT ========= */
    loadDashboard();
  </script>
</body>
</html>
















